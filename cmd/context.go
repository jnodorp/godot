package cmd

import (
	"os"
	"regexp"
	"runtime"
	"strings"

	log "github.com/sirupsen/logrus"
	"github.com/spf13/viper"
)

const headerPrefix string = "Generated by godot"
const headerSuffix string = "."

// matchers determine whether a property of the system (e.g. the hostname) matches a profile
var matchers = []func(string) bool{matchOs, matchHostname}

// Context used to render templates
type Context struct {
	Profiles []string
}

// Env builds a map of all available environment variables
func (c Context) Env() map[string]string {
	env := make(map[string]string)
	for _, pair := range os.Environ() {
		v := strings.Split(pair, "=")
		env[v[0]] = v[1]
	}

	return env
}

// Header returns a header that can be used in generated files
func (c Context) Header(msg ...string) string {
	return headerPrefix + strings.Join(msg, " ") + headerSuffix
}

// Hostname determines the hostname
func (c Context) Hostname() string {
	hostname, err := os.Hostname()
	if err != nil {
		log.WithError(err).Warn("could not determine hostname")
	}

	return hostname
}

// Os determines the operation system
func (c Context) Os() string {
	return runtime.GOOS
}

// ProfilesContain can be used in templates to determine if a profile is active
func (c Context) ProfilesContain(profile string) bool {
	return c.ProfilesContainAnyOf(profile)
}

// ProfilesContainAnyOf can be used in templates to determine if profiles are active
func (c Context) ProfilesContainAnyOf(profiles ...string) bool {
	for _, p1 := range c.Profiles {
		for _, p2 := range profiles {
			if p1 == p2 {
				return true
			}
		}
	}

	return false
}

// NewContext creates a new context loading the active profiles.
func NewContext() *Context {
	return &Context{
		Profiles: profiles(),
	}
}

// profiles determines the matching profiles
func profiles() []string {
	result := make([]string, 0)

	// Determine matching profiles.
	profiles := viper.GetStringMap("profiles")
	for profile := range profiles {
		match := true
		for _, matcher := range matchers {
			if !matcher(profile) {
				match = false
				break
			}
		}

		if match {
			result = append(result, profile)
			log.WithField("profile", profile).Info("applied profile")
		}
	}

	return result
}

func matchOs(profile string) bool {
	// Set default value matching everything.
	viper.SetDefault("profiles."+profile+".os", ".*")

	regex := viper.GetString("profiles." + profile + ".os")

	match, err := regexp.MatchString(regex, runtime.GOOS)
	if err != nil {
		log.WithError(err).Fatal("matching OS failed")
	}

	if !match {
		log.WithField("profile", profile).Infof("OS '%s' does not match '%s'", runtime.GOOS, regex)
	}

	return match
}

func matchHostname(profile string) bool {
	// Set default value matching everything.
	viper.SetDefault("profiles."+profile+".hostname", ".*")

	regex := viper.GetString("profiles." + profile + ".hostname")

	hostname, err := os.Hostname()
	if err != nil {
		log.WithError(err).Warn("skipping hostname matching because hostname could not be determined")
		return true
	}

	match, err := regexp.MatchString(regex, hostname)
	if err != nil {
		log.WithError(err).Fatal("matching hostname failed")
	}

	if !match {
		log.WithField("profile", profile).Infof("Hostname '%s' does not match '%s'", hostname, regex)
	}

	return match
}
